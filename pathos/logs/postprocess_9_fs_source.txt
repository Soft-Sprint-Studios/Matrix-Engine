#version 460
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect texture0;
uniform vec4 color;
uniform float screenwidth;
uniform float screenheight;

in vec2 ps_texcoord;
out vec4 oColor;

uniform float FXAAStrength;
void main()
{
	vec2 texelSize = 1.0 / vec2(screenwidth, screenheight);
    vec4 color = texture(texture0, ps_texcoord);
    vec2 texCoord = ps_texcoord;

    vec3 rgbNW = texture(texture0, texCoord + vec2(-1, -1) * texelSize).rgb;
    vec3 rgbNE = texture(texture0, texCoord + vec2(1, -1) * texelSize).rgb;
    vec3 rgbSW = texture(texture0, texCoord + vec2(-1, 1) * texelSize).rgb;
    vec3 rgbSE = texture(texture0, texCoord + vec2(1, 1) * texelSize).rgb;
    vec3 rgbM = texture(texture0, texCoord).rgb;

    // Convert to grayscale
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    // Compute direction
    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));
    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAAStrength), 0.001);
    float rcpDirMin = 1.0 / min(abs(dir.x), abs(dir.y));
    dir = min(vec2(FXAAStrength), max(vec2(-FXAAStrength), dir * rcpDirMin)) * dirReduce;

    // Sample neighboring pixels
    vec3 rgbA = 0.5 * (texture(texture0, texCoord + dir * (1.0 / 3.0 - 0.5)).rgb + 
                       texture(texture0, texCoord + dir * (2.0 / 3.0 - 0.5)).rgb);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (texture(texture0, texCoord + dir * -0.5).rgb + 
                                      texture(texture0, texCoord + dir * 0.5).rgb);

    float lumaB = dot(rgbB, luma);
    oColor = vec4((lumaB < lumaMin || lumaB > lumaMax) ? rgbA : rgbB, color.a);
vec2 texelSizeSSAO = 1.0 / vec2(screenwidth, screenheight);

    vec3 rgbM_SSAO = texture(texture0, ps_texcoord).rgb;

    vec3 rgbNW_SSAO = texture(texture0, ps_texcoord + vec2(-1, -1) * texelSizeSSAO * SSAORadius).rgb;
    vec3 rgbNE_SSAO = texture(texture0, ps_texcoord + vec2(1, -1) * texelSizeSSAO * SSAORadius).rgb;
    vec3 rgbSW_SSAO = texture(texture0, ps_texcoord + vec2(-1, 1) * texelSizeSSAO * SSAORadius).rgb;
    vec3 rgbSE_SSAO = texture(texture0, ps_texcoord + vec2(1, 1) * texelSizeSSAO * SSAORadius).rgb;

    vec3 luma_SSAO = vec3(0.299, 0.587, 0.114);
    float lumaNW_SSAO = dot(rgbNW_SSAO, luma_SSAO);
    float lumaNE_SSAO = dot(rgbNE_SSAO, luma_SSAO);
    float lumaSW_SSAO = dot(rgbSW_SSAO, luma_SSAO);
    float lumaSE_SSAO = dot(rgbSE_SSAO, luma_SSAO);
    float lumaM_SSAO = dot(rgbM_SSAO, luma_SSAO);

    float lumaMin_SSAO = min(lumaM_SSAO, min(min(lumaNW_SSAO, lumaNE_SSAO), min(lumaSW_SSAO, lumaSE_SSAO)));
    float lumaMax_SSAO = max(lumaM_SSAO, max(max(lumaNW_SSAO, lumaNE_SSAO), max(lumaSW_SSAO, lumaSE_SSAO)));

    float occlusionFactor_SSAO = clamp((lumaM_SSAO - lumaMin_SSAO) / (lumaMax_SSAO - lumaMin_SSAO), 0.0, 1.0);

    vec3 finalColor_SSAO = rgbM_SSAO * (1.0 - occlusionFactor_SSAO * SSAOStrength);

    oColor = vec4(finalColor_SSAO, 1.0);
}
