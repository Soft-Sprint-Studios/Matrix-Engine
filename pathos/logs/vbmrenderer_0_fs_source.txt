#version 460
#extension GL_ARB_texture_rectangle : enable

uniform sampler2D texture0;
uniform sampler2D texture1;
uniform sampler2DRect rectangle;

uniform vec3 skylight_ambient;
uniform vec3 skylight_diffuse;
uniform vec3 skylight_dir;

uniform float light_radius;

uniform vec3 fogcolor;
uniform vec2 fogparams;

uniform sampler2D spectexture;

uniform sampler2D aotex;
uniform float aoscale;

uniform sampler2D normalmap;

uniform vec4 color;

uniform float phong_exponent;
uniform float specfactor;
uniform float caust_interp;

uniform float scope_scale;
uniform vec2 scope_scrsize;

uniform vec3 lights_0_origin;
uniform vec3 lights_0_color;
uniform float lights_0_radius;

uniform vec3 lights_1_origin;
uniform vec3 lights_1_color;
uniform float lights_1_radius;

uniform vec3 lights_2_origin;
uniform vec3 lights_2_color;
uniform float lights_2_radius;

uniform vec3 lights_3_origin;
uniform vec3 lights_3_color;
uniform float lights_3_radius;

uniform vec3 lights_4_origin;
uniform vec3 lights_4_color;
uniform float lights_4_radius;

uniform vec3 lights_5_origin;
uniform vec3 lights_5_color;
uniform float lights_5_radius;

in vec3 ps_vertexpos;
in vec3 ps_tangent;
in vec3 ps_binormal;
in vec3 ps_normal;
in vec2 ps_texcoord1;
in vec2 ps_texcoord2;
in vec4 ps_dlight_0_vertexcoord;
in vec4 ps_dlight_1_vertexcoord;
in vec4 ps_dlight_2_vertexcoord;
in vec4 ps_dlight_3_vertexcoord;

out vec4 oColor;

float CalcShininess( vec3 v_dir, vec3 v_normal, vec3 l_dir )
{
return 1.0;
}

float LinearStep(float in1, float in2, float pmax)  
{  
	float value = (pmax-in1)/(in2-in1);
	return clamp(value, 0.0, 1.0);
}

float ReduceLightBleeding(float p_max, float Amount)  
{    
	return LinearStep(Amount, 1, p_max);  
}

float DepthTestCube( float depthcoord, samplerCube shadowmap, vec3 coord )
{
	vec4 momments = texture(shadowmap, coord);
	momments.xy = momments.xy+momments.zw/32;

	float diff = depthcoord-momments.x;
	float sgn = max(sign(diff), 0);

	float variance = momments.y-(momments.x*momments.x);
	variance = max(variance, 0.00005);
	
	float d = depthcoord-momments.x;
	float p_max = variance/(variance+d*d);
	return p_max*sgn+(1.0-sgn);
}

float DepthTestProj( float depthcoord, sampler2D shadowmap, vec4 coord )
{
	vec4 momments = textureProj(shadowmap, coord);
	momments.xy = momments.xy+momments.zw/32;

	float diff = depthcoord-momments.x;
	float sgn = max(sign(diff), 0);

	float variance = momments.y-(momments.x*momments.x);
	variance = max(variance, 0.00005);
	
	float d = depthcoord-momments.x;
	float p_max = variance/(variance+d*d);
	return p_max*sgn+(1.0-sgn);
}

float CalcFresnel(vec3 eyeVec, vec3 reflectVec) {
    float baseReflectance = 0.04;
    float factor = pow(1.0 - dot(eyeVec, reflectVec), 5.0);
    return baseReflectance + (1.0 - baseReflectance) * factor;
}

float OrenNayarReflectance(vec3 v_normal, vec3 lightDir, vec3 viewDir, float roughness) {
    float sigma2 = roughness * roughness;
    float A = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33);
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    
    float cosThetaI = dot(lightDir, v_normal);
    float cosThetaR = dot(viewDir, v_normal);
    
    float thetaI = acos(cosThetaI);
    float thetaR = acos(cosThetaR);
    
    float alpha = max(thetaI, thetaR);
    float beta = min(thetaI, thetaR);
    
    vec3 lightPerpendicular = normalize(lightDir - v_normal * cosThetaI);
    vec3 viewPerpendicular = normalize(viewDir - v_normal * cosThetaR);
    
    float cosPhiDiff = max(0.0, dot(lightPerpendicular, viewPerpendicular));
    
    float diffuse = A + B * cosPhiDiff * sin(alpha) * tan(beta);
    
    return diffuse;
}

float CalcSpecular(vec3 v_origin, vec3 v_normal, vec3 lightDir, float specularStrength) {
    vec3 eyeVec = normalize(-v_origin);
    vec3 reflectVec = reflect(lightDir, v_normal);
    float cosAlpha = clamp(dot(eyeVec, reflectVec), 0.0, 1.0);
    
    vec4 specularColor = texture(spectexture, ps_texcoord.xy);
    float specularReflectance = specularColor.r;
    vec3 specularTint = specularColor.rgb;

    float roughness = 1.0 - specularColor.a;

    float specularComponent = specfactor * pow(cosAlpha, phong_exponent) * specularStrength * specularReflectance;
    float fresnel = CalcFresnel(eyeVec, reflectVec);
    vec3 finalSpecular = mix(specularTint, vec3(1.0), fresnel) * specularComponent;

    float diffuseReflectance = OrenNayarReflectance(v_normal, lightDir, eyeVec, roughness);

    return dot(finalSpecular, vec3(1.0)) * diffuseReflectance;
}

vec4 AddModelLight( vec3 l_origin, vec3 l_color, float l_radius, vec3 v_origin, vec3 v_normal, float specularStrength )
{
	// Inverse squared radius
	float rad = l_radius * l_radius;
	vec3 dir = l_origin - v_origin;

	float dist = dot(dir, dir);
	//float attn = rad / (dist * sqrt(dist));
	float attn = ((dist/rad)-1)*-1;
	
	attn = clamp(attn, 0.0, 1.0);
	dir = normalize(dir);
	float dp = dot(dir, v_normal);
	
	vec4 outColor;
	outColor.xyz = l_color*attn*max(dp, 0);
	
	return outColor;
}

vec4 AddPointLight( float l_radius, vec3 l_origin, vec3 l_color, vec3 v_origin, vec4 v_coord, vec3 v_normal, float specularStrength )
{
	// Inverse squared radius
	float rad = l_radius * l_radius;
	vec3 dir = l_origin - v_origin;
	
	float dist = dot(dir, dir);
	float attn = (dist/rad-1)*-1;
	
	dir = normalize(dir);
	attn = clamp(attn, 0.0, 1.0);
	float dp = dot(dir, v_normal);

	attn = max(dp, 0)*attn;
	vec4 outColor;
	outColor.xyz = attn*l_color;
	
	return outColor;
}

float GetPointLightShadowing( float l_radius, vec4 v_coord, samplerCube l_shadowmap )
{
	float fldistance = clamp((length(v_coord.xyz)/l_radius), 0.0, 1.0);
	float flresult = DepthTestCube(fldistance, l_shadowmap, normalize(v_coord.xyz));
	return ReduceLightBleeding(flresult, 0.4);
}

vec4 AddProjLight( float l_radius, vec3 l_origin, vec3 l_color, vec3 v_origin, vec4 v_coord, vec3 v_normal, sampler2D l_texture, float specularStrength )
{
	float rad = l_radius*l_radius;
	vec3 dir = l_origin-v_origin;
	float dist = dot(dir, dir);
	float attn = (dist/rad-1)*-1;
	attn = clamp(attn, 0.0, 1.0);
	
	dir = normalize(dir);
	float dp = max(dot(dir, v_normal), 0);
	vec4 texclamp = max(v_coord, 0);

	vec4 texColor = textureProj(l_texture, texclamp);
	
	vec4 outColor;
	outColor.xyz = attn*texColor.xyz*l_color*dp;
	
	return outColor;
}

float GetProjLightShadowing( float l_radius, vec3 l_origin, vec3 v_origin, vec4 v_coord, sampler2D l_shadowmap )
{
	vec4 texclamp = max(v_coord, 0);
	float fldistance = clamp((length(l_origin-v_origin)/l_radius), 0.0, 1.0);
	float flresult = DepthTestProj(fldistance, l_shadowmap, texclamp);
	return ReduceLightBleeding(flresult, 0.4);
}

vec4 AddBaseLight( vec3 s_lightdir, vec3 s_ambient, vec3 s_diffuse, vec3 v_normal, vec3 v_origin, float specularStrength )
{
	float fldot = -dot(s_lightdir, v_normal);
	
	vec4 outColor;
	outColor.xyz = s_ambient+fldot*s_diffuse;
	
	return outColor;
}

vec3 AddDiffuseLight ( vec3 colorIn1, vec3 colorIn2 )
{
	vec3 outValue = colorIn1;
	outValue += colorIn2;
	return outValue;
}

vec3 AddDiffuseDynamicLight ( vec3 colorIn1, vec3 colorIn2 )
{
	vec3 outValue = colorIn1;
	outValue += colorIn2;
	return outValue;
}

vec3 AddSpecularLight ( vec3 colorIn1, float specularStrength, vec3 colorIn2 )
{
	vec3 outValue = colorIn1;
	return outValue;
}

vec4 EncodeDepth( vec3 v_origin, float l_radius )
{
	float depth = length(v_origin);
	depth = clamp((depth/l_radius), 0.0, 1.0);

	vec2 momments = vec2(depth, depth*depth);
	float dx = dFdx(depth);
	float dy = dFdy(depth);
	momments.y += 0.25*(dx*dx+dy*dy);

	vec2 fracval = fract(momments*32);

	vec4 finalColor;
	finalColor.x = momments.x-(fracval.x/32);
	finalColor.y = momments.y-(fracval.y/32);
	finalColor.zw = fracval;
	
	return finalColor;
}

float SplineFraction( float value, float scale )
{
	float valueSquared;

	value = scale * value;
	valueSquared = value * value;

	// Nice little ease-in, ease-out spline-like curve
	return 3 * valueSquared - 2 * valueSquared * value;
}

float CalcFogFactor( vec3 v_origin, vec2 f_params )
{
	float fp_fogcoord = length(v_origin);
	float fp_fogfactor = (f_params.x - fp_fogcoord)*f_params.y;
	
	return 1.0-SplineFraction(clamp(fp_fogfactor, 0.0, 1.0), 1.0);
}

vec3 GetNormal( vec2 texcoord, sampler2D normalmap, vec3 v_normal, mat3 tbnMatrix )
{
return v_normal;
}

void main()
{
	mat3 tbnMatrix;
	float specularFactor = 0.0;
	vec4 specularColor = vec4(0.0, 0.0, 0.0, 0.0);
	vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
	
	// Add luminance of any
	// Get the specular texture if needed
	// Build the TBN matrix if required
	// Shut up compiler warnings
		tbnMatrix = mat3(vec3(0, 0, 0), vec3(0, 0, 0), vec3(0, 0, 0));
	// Normal depends on rendering type
	vec3 v_normal = GetNormal(ps_texcoord1, normalmap, ps_normal, tbnMatrix);
	
	// Base lighting
	vec4 lightColor;
	lightColor = AddBaseLight(skylight_dir, skylight_ambient, skylight_diffuse, v_normal, ps_vertexpos, specularFactor);
		
		// Add in the diffuse light
			finalColor.xyz = AddDiffuseLight(finalColor.xyz, lightColor.xyz);
		// Add to specular
		specularColor.xyz = AddSpecularLight(specularColor.xyz, lightColor.w, skylight_diffuse);
	// Elights
	// Normal single pass rendering
	finalColor = clamp(finalColor, 0.0, 1.0); // To prevent multipass inconsistencies
		vec4 textureColor = texture(texture0, ps_texcoord1);
		finalColor = finalColor*textureColor + specularColor;
		finalColor.xyz *= 2;
		finalColor = finalColor*color;
	// Lighting without textures but with alpha
	// Dynamic light passes
	// Caustics
	// Solid color
	// VSM shadow encoding
	// Fog only with fog factor as alpha
	// Texture with no lighting
	// Scope
	// Texture only and with fog
	// Texture with alpha holes for decals
	// Fog calculations
	// Specular only
	oColor = finalColor;
}
